import unittest
import sys
import os
import time # Import time module
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from .solution import Solution # Corrected import for standard test discovery
import collections
import itertools

# --- Reference Solution (Brute-Force) ---
def reference_solution(num_str: str) -> int:
    n = len(num_str)
    digits = [int(d) for d in num_str]
    
    # Optimization for reference_solution: if sum is odd, return 0 immediately
    if sum(digits) % 2 != 0:
        return 0
        
    distinct_permutations_str = set()
    for p_tuple in itertools.permutations(digits): # Produces permutations of the list of numbers
        distinct_permutations_str.add("".join(map(str, p_tuple)))

    balanced_count = 0
    for p_str in distinct_permutations_str:
        current_digits = [int(d) for d in p_str] # Re-convert, though p_tuple could be used.
        sum_even_indices = 0
        sum_odd_indices = 0
        for i in range(n):
            if (i + 1) % 2 == 0: # 1-indexed even position (0-indexed odd)
                sum_odd_indices += current_digits[i]
            else: # 1-indexed odd position (0-indexed even)
                sum_even_indices += current_digits[i]
        
        if sum_even_indices == sum_odd_indices:
            balanced_count += 1
            
    return balanced_count

class TestCountBalancedPermutations(unittest.TestCase):

    def setUp(self):
        self.solver = Solution()
        self.startTime = time.time()
        self.N_max_for_reference = 8 

    def tearDown(self):
        t = time.time() - self.startTime
        # print(f"{self.id()}: {t:.4f}s")

    # --- Category 1: Problem Examples ---
    def test_example_1(self):
        num = "123"
        expected_problem_ans = 2
        self.assertEqual(self.solver.countBalancedPermutations(num), expected_problem_ans)
        if len(num) <= self.N_max_for_reference:
            self.assertEqual(reference_solution(num), expected_problem_ans)

    def test_example_2(self):
        num = "112"
        expected_problem_ans = 1
        self.assertEqual(self.solver.countBalancedPermutations(num), expected_problem_ans)
        if len(num) <= self.N_max_for_reference:
            self.assertEqual(reference_solution(num), expected_problem_ans)

    def test_example_3(self):
        num = "12345" # Sum is odd
        expected_problem_ans = 0
        self.assertEqual(self.solver.countBalancedPermutations(num), expected_problem_ans)
        if len(num) <= self.N_max_for_reference:
            self.assertEqual(reference_solution(num), expected_problem_ans)

    # --- Category 2: Custom Edge Cases ---
    # Answers for these MUST be generated by reference_solution.
    
    def test_custom_all_same_digits_even_len_balanced(self):
        num = "11" # "11" -> e=1, o=1. Balanced. Count = 1.
        if len(num) <= self.N_max_for_reference:
            expected = reference_solution(num)
            self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        else:
            # This case should ideally not be hit for Cat 2 if num is chosen appropriately.
            # If it's too large, it's not a Cat 2 test for reference_solution.
            pass 

    def test_custom_all_same_digits_odd_len_sum_odd(self):
        num = "111" # sum=3 (odd), expected = 0
        # Both solution and reference_solution should handle sum % 2 != 0 early.
        expected = 0 # Known due to odd sum
        self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        if len(num) <= self.N_max_for_reference:
             self.assertEqual(reference_solution(num), expected) # reference_solution also returns 0

    def test_custom_all_same_digits_odd_len_sum_even_unbalanced(self):
        num = "222" # sum=6 (even). N=3, Ne=2,No=1. Target_half_sum=3.
                      # Only perm is "222". Even_idx_sum = 2+2=4. Odd_idx_sum=2. Not balanced. Expected=0
        if len(num) <= self.N_max_for_reference:
            expected = reference_solution(num)
            self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        else:
            pass

    def test_custom_two_distinct_digits_no_balance(self):
        num = "12" # "12" (e:1,o:2), "21" (e:2,o:1). Total sum 3. Expected = 0.
        expected = 0 # Known due to odd sum
        self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        if len(num) <= self.N_max_for_reference:
            self.assertEqual(reference_solution(num), expected)
            
    def test_custom_zeros_balanced(self):
        num = "000" # sum=0. Perm: "000" (e:0,0; o:0) sums 0,0. Balanced. Count=1
        if len(num) <= self.N_max_for_reference:
            expected = reference_solution(num)
            self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        else:
            pass
            
    def test_custom_simple_balanced(self):
        num = "101" 
        # Distinct perms of "101": "101", "011", "110"
        # "101": e=1(pos 0)+1(pos 2)=2, o=0(pos 1)=0. No
        # "011": e=0(pos 0)+1(pos 2)=1, o=1(pos 1)=1. Yes
        # "110": e=1(pos 0)+0(pos 2)=1, o=1(pos 1)=1. Yes
        # Expected = 2
        if len(num) <= self.N_max_for_reference:
            expected = reference_solution(num)
            self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        else:
            pass

    def test_custom_slightly_larger_balanced(self):
        num = "1122" # N=4, Ne=2, No=2. Sum=6, Target_half=3
        # Perms "1122" (e:1,2 o:1,2 -> e:3,o:3 Yes!), "1212" (e:1,1 o:2,2 -> e:2,o:4 No), "1221" (e:1,2 o:2,1 -> e:3,o:3 Yes!)
        # "2112" (e:2,1 o:1,2 -> e:3,o:3 Yes!), "2121" (e:2,2 o:1,1 -> e:4,o:2 No), "2211" (e:2,1 o:2,1 -> e:3,o:3 Yes!)
        # Distinct perms: "1122", "1212", "1221", "2112", "2121", "2211" (6 distinct)
        # Balanced: "1122", "1221", "2112", "2211". Count = 4
        if len(num) <= self.N_max_for_reference:
            expected = reference_solution(num)
            self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        else:
            pass
            
    def test_custom_s_total_odd_longer(self):
        num = "11111" # sum = 5 (odd)
        expected = 0 # Known due to odd sum
        self.assertEqual(self.solver.countBalancedPermutations(num), expected)
        if len(num) <= self.N_max_for_reference:
            self.assertEqual(reference_solution(num), expected)

    # --- Category 3: Performance Stress Tests ---
    def run_performance_test(self, num_str, test_name):
        # solve_method should be Solution().countBalancedPermutations, not self.solver to ensure fresh cache if not cleared
        solve_method = Solution().countBalancedPermutations 
        
        start_time = time.time()
        solve_method(num_str) # Result is not checked
        end_time = time.time()
        duration = end_time - start_time
        print(f"Performance test {test_name} for N={len(num_str)} ({num_str[:10]}...): {duration:.4f}s")

    def test_performance_max_n_all_ones(self):
        self.run_performance_test("1" * 80, "max_n_all_ones")

    def test_performance_max_n_all_nines(self):
        self.run_performance_test("9" * 80, "max_n_all_nines")

    def test_performance_max_n_alternating_small(self):
        self.run_performance_test("12" * 40, "max_n_alternating_small")
    
    def test_performance_max_n_alternating_large(self):
        self.run_performance_test("89" * 40, "max_n_alternating_large")

    def test_performance_max_n_mostly_zeros(self):
        self.run_performance_test("0" * 78 + "11", "max_n_mostly_zeros")

    def test_performance_max_n_mixed_high_sum(self):
        self.run_performance_test("9" * 40 + "8" * 40, "max_n_mixed_high_sum")
        
    def test_performance_max_n_random_like(self):
        self.run_performance_test("0"*16 + "1"*16 + "2"*16 + "3"*16 + "4"*16, "max_n_random_like")

if __name__ == '__main__':
    # Add the parent directory to sys.path to allow direct execution of this test file
    # and relative import of .solution
    current_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(current_dir)
    if parent_dir not in sys.path: # Avoid adding it multiple times if script is run interactively
        sys.path.insert(0, parent_dir)
    
    # This allows running the test file directly, e.g. python test_solution.py
    # The import '.solution' should work if this file is in 'problem_XXXX' and solution.py is also there.
    # Or, if 'problem_XXXX' is a package.
    # For `python -m unittest ...` from root, this path manipulation is less critical if structure is standard.

    unittest.main(argv=['first-arg-is-ignored'], exit=False) 