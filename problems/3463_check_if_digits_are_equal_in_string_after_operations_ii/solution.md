# 3463. Check If Digits Are Equal in String After Operations II - Solution Analysis\n\n## Problem Summary\n\nGiven a string `s` of digits, repeatedly perform an operation: replace `s` with the digit-wise sum modulo 10 of adjacent pairs. Stop when `s` has length 2. Return `true` if the two final digits are equal, `false` otherwise.\n\nConstraints: `3 <= len(s) <= 10^5`.\n\n## Approach 1: Binomial Coefficients (Lucas + CRT) - O(n log n)\n\n### Logic\n\n1.  **Observation:** The operation resembles Pascal's triangle modulo 10. After `k = n - 2` operations, the final two digits `d0` and `d1` can be expressed as linear combinations of the original digits `s[0], s[1], ..., s[n-1]`:\n    *   `d0 = sum_{i=0}^{k} C(k, i) * s[i] mod 10`\n    *   `d1 = sum_{i=0}^{k} C(k, i) * s[i+1] mod 10`\n2.  **Goal:** Check if `d0 == d1`.\n3.  **Calculation:** This requires calculating `C(k, i) mod 10` for `i = 0` to `k`.\n4.  **`C(k, i) mod 10`:** Since 10 is composite (2 * 5), we calculate `C(k, i) mod 2` and `C(k, i) mod 5` separately and combine them using the Chinese Remainder Theorem (CRT).\n    *   **`mod 5`:** Use Lucas's Theorem. `C(n, r) mod p` can be computed by looking at base-p representations. [[../../techniques/combinatorics/binomial_coefficient_modulo.md]]\n    *   **`mod 2`:** Use Kummer's Theorem or bit manipulation. `C(n, r) mod 2 = 1` iff `(n & r) == r`.\n    *   **CRT:** Combine the results using a precomputed lookup table.\n\n### Complexity\n\n*   **Time:** `O(k log k)` or `O(n log n)`. See [[../../optimizations/combinatorics/nCr_sequence_lucas_vs_iterative.md]] for why this is suboptimal for sequences.\n*   **Space:** `O(n)` to store digits, `O(1)` extra space (excluding input/output) if coefficients are calculated on the fly, or `O(k)` if precomputed.\n\n## Approach 2: Difference Array + Iterative Coefficients - O(n)\n\n### Logic\n\n1.  **Reformulation:** The condition `d0 == d1` is equivalent to `d0 - d1 == 0 mod 10`.\n    `d0 - d1 = sum_{i=0}^{k} C(k, i) * (s[i] - s[i+1]) mod 10`.\n    Let `D[i] = s[i+1] - s[i]`. The goal is to check if `sum_{i=0}^{k} C(k, i) * (-D[i]) % 10 == 0`, or equivalently `sum_{i=0}^{k} C(k, i) * D[i] % 10 == 0`.\n    This avoids calculating `d0` and `d1` separately. See [[../../optimizations/problem_reformulation/difference_array.md]].\n2.  **Symmetry:** Exploit `C(k, i) = C(k, k-i)`. The sum can be folded: `Sum = Sum_{i=0}^{floor((k-1)/2)} C(k, i) * (D[i] + D[k-i]) + (middle term if k is odd)`. This halves the number of coefficients needed. See [[../../optimizations/loop_optimization/symmetry_exploitation.md]].\n3.  **Iterative `C(k, i) mod 10`:** Instead of recalculating each `C(k, i) mod 10`, compute them iteratively based on `C(k, i-1) mod 10`. This is the key optimization allowing O(n) time. See [[../combinatorics/iterative_nCr_modulo.md]] for the technique and [[../../optimizations/combinatorics/nCr_sequence_lucas_vs_iterative.md]] for the optimization rationale.\n\n### Complexity\n\n*   **Time:** `O(n)`. The difference array is `O(n)`. The loop runs `k/2` or `n/2` times. Inside the loop, the iterative coefficient calculation is amortized `O(1)`. Overall complexity is dominated by the loop, making it `O(n)`.\n*   **Space:** `O(n)` for the difference array. `O(1)` for the iterative state variables.\n\n## Conclusion\n\nThe `O(n)` approach using the difference array formulation and the iterative calculation of binomial coefficients modulo 10 is significantly faster than the `O(n log n)` approach relying on repeated Lucas's Theorem calculations, especially given the constraint `n <= 10^5`. The iterative method avoids redundant computations inherent in calculating each coefficient from scratch. 