# Optimization: Dual Path Grid DP - Top-Down vs Bottom-Up\n\n## Context\n\nWhen implementing the **Dual Path Grid DP pattern** (see [[../../patterns/matrix/dual_path_grid_dp.md]]), two primary dynamic programming approaches are common: Top-Down (Memoized Recursion) and Bottom-Up (Tabulation).\n\nWhile both solve the same problem with the same asymptotic time complexity (O(N^3)), they have different space complexities and practical performance characteristics worth comparing.\n\n## Approach Comparison\n\n1.  **Bottom-Up (Tabulation with O(N^2) Space):**\n    *   **Implementation:** Iterates through steps `t`, calculating `new_dp[r1][r2]` based on the previous step's `dp[r1][r2]`. Requires only two layers (current and previous) of the DP state, reducing space.\n    *   **Space Complexity:** O(N^2)\n    *   **Time Complexity:** O(N^3)\n    *   **Pros:** Best theoretical space complexity.\n    *   **Cons:** Iterates through all possible `(r1, r2)` pairs at each step, potentially doing unnecessary work if many states are unreachable (e.g., due to many thorns in the grid). Implementing symmetry pruning (`r1 <= r2`) might require slightly more complex loop bounds or checks.\n\n2.  **Top-Down (Memoized Recursion):**\n    *   **Implementation:** Uses a recursive function `dp(state...)` with memoization (e.g., `@cache`).\n    *   **Space Complexity:** O(N^3) (Worst-case for the memoization cache).\n    *   **Time Complexity:** O(N^3)\n    *   **Pros:**\n        *   **Sparse State Efficiency:** Naturally explores only reachable states. Can be significantly faster in practice if the grid contains many obstacles, avoiding computation for unreachable `(r1, r2)` pairs.\n        *   **Symmetry Pruning:** Easily implements symmetry optimization (e.g., checking `if r1 > r2: ...`) which prunes ~half the state space, reducing the constant factor of the time complexity.\n        *   **Implementation:** Can feel more direct, mapping closely to the recursive state definition.\n    *   **Cons:** Higher theoretical space complexity.\ Python recursion depth limits could be a concern for extremely large N (though typically not for N=50).\n\n## Recommendation\n\n*   For grids where the state space is dense (few obstacles) and memory is highly constrained, the **Bottom-Up O(N^2) space** approach is preferable.\n*   For grids that might be sparse (many obstacles) or when implementation simplicity is valued, the **Top-Down O(N^3) space** approach, especially with **symmetry pruning**, is often faster in practice and easier to code correctly.\n\nGiven typical competitive programming constraints and Python's efficient `@cache`, the Top-Down approach with symmetry pruning is frequently a strong choice for this pattern.\n\n## Related Concepts\n\n*   **Pattern:** [[../../patterns/matrix/dual_path_grid_dp.md]]\n*   **Algorithm:** [[../../algorithms/dynamic_programming/dynamic_programming.md]]\n 